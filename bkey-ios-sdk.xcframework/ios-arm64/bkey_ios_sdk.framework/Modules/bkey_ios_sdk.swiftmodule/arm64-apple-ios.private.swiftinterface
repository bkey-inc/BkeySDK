// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios16.1 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name bkey_ios_sdk
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Combine
import CoreData
import CoreNFC
import CryptoKit
import CryptoKit/*.Digest*/
import CryptoKit/*.SHA256*/
import CryptoKit/*.SharedSecret*/
import Foundation
import Swift
import SwiftUI
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import bkey_ios_sdk
import os.lock
import os
import secp256k1

public enum NFCCardException : Swift.Error {
  case CardWasEmpty
  case FailedToReadCard(Swift.String)
  case FailedToScanCard(Swift.String)
  case FailedToWriteToCard(Swift.String)
  case OperationCanceled
}
public enum BkeyException : Swift.Error {
  case FrameworkNotInitialized
  case AccessNotAllowed
  case FrameworkError(Swift.String)
}

@_hasMissingDesignatedInitializers public class Bkey {
  public static let shared: bkey_ios_sdk.Bkey
  public func OnIdentityCreated(userId: Swift.String, displayName: Swift.String, authToken: Swift.String)
  public func OnIdentityVerified(userId: Swift.String, displayName: Swift.String, authToken: Swift.String)
  @objc deinit
}
extension bkey_ios_sdk.Bkey {
  #if compiler(>=5.3) && $AsyncAwait
  public func Initialize(authToken: Swift.String) async throws
  #endif
  public func CloseSession() throws
  public func Authenticate() -> some SwiftUI.View
  
  public func VerifyCurrentUserBiometrics() throws -> Swift.Bool
  public func VerifyCurrentUserNfcCard() throws -> Swift.Bool
  public func SignData(data: Foundation.Data) throws -> Foundation.Data
  public func VerifyDataSignature(data: Foundation.Data, signature: Foundation.Data) throws -> Swift.Bool
  public func EncryptString(value: Swift.String) throws -> Swift.String
  public func DecryptString(value: Swift.String) throws -> Swift.String
  public func EncryptData(data: Foundation.Data) throws -> [Swift.UInt8]
  public func DecryptData(data: Foundation.Data) throws -> [Swift.UInt8]
  public func GetCryptoSeedPhrase() throws
}

extension bkey_ios_sdk.K1 {
  public enum KeyAgreement {
  }
}
extension bkey_ios_sdk.K1.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKey: bkey_ios_sdk.K1.KeyAgreement.PrivateKey.PublicKey) throws -> CryptoKit.SharedSecret
  public func ecdh(with publicKey: bkey_ios_sdk.K1.KeyAgreement.PrivateKey.PublicKey, arbitraryData: Foundation.Data? = nil) throws -> CryptoKit.SharedSecret
  public func ecdhPoint(with publicKey: bkey_ios_sdk.K1.KeyAgreement.PrivateKey.PublicKey) throws -> Foundation.Data
}
extension bkey_ios_sdk.K1.ECDSA.PublicKey {
  public func isValidSignature(_ signature: bkey_ios_sdk.K1.ECDSA.Signature, hashed: some DataProtocol, options: bkey_ios_sdk.K1.ECDSA.ValidationOptions = .default) -> Swift.Bool
  public func isValidSignature(_ signature: bkey_ios_sdk.K1.ECDSA.Signature, digest: some Digest, options: bkey_ios_sdk.K1.ECDSA.ValidationOptions = .default) -> Swift.Bool
  public func isValidSignature(_ signature: bkey_ios_sdk.K1.ECDSA.Signature, unhashed: some DataProtocol, options: bkey_ios_sdk.K1.ECDSA.ValidationOptions = .default) -> Swift.Bool
}
extension bkey_ios_sdk.K1.Schnorr.PublicKey {
  public func isValidSignature(_ signature: bkey_ios_sdk.K1.Schnorr.Signature, hashed: some DataProtocol) -> Swift.Bool
  public func isValidSignature(_ signature: bkey_ios_sdk.K1.Schnorr.Signature, digest: some Digest) -> Swift.Bool
  public func isValidSignature(_ signature: bkey_ios_sdk.K1.Schnorr.Signature, unhashed: some DataProtocol) -> Swift.Bool
}
extension Foundation.ContiguousBytes {
  @inlinable internal var bytes: [Swift.UInt8] {
    get {
		withUnsafeBytes { pointer in
			Array(pointer)
		}
	}
  }
}
extension bkey_ios_sdk.K1 {
  public enum Schnorr {
  }
}
extension bkey_ios_sdk.K1.Schnorr {
  public struct SigningOptions : Swift.Sendable, Swift.Hashable {
    public let auxiliaryRandomData: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData
    public init(auxiliaryRandomData: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData = .default)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Schnorr.SigningOptions, b: bkey_ios_sdk.K1.Schnorr.SigningOptions) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.Schnorr.SigningOptions {
  public static let `default`: bkey_ios_sdk.K1.Schnorr.SigningOptions
  public enum AuxiliaryRandomData : Swift.Sendable, Swift.Hashable {
    case none
    case specific(bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData.Aux32)
    case random
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData, b: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData {
  public static let `default`: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData
  public struct Aux32 : Swift.Sendable, Swift.Hashable {
    public let aux: [Swift.UInt8]
    public static let byteCount: Swift.Int
    public init(aux: some DataProtocol) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData.Aux32, b: bkey_ios_sdk.K1.Schnorr.SigningOptions.AuxiliaryRandomData.Aux32) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}

extension bkey_ios_sdk.K1.KeyAgreement {
  public struct PrivateKey : Swift.Sendable, Swift.Hashable {
    public typealias PublicKey = bkey_ios_sdk.K1.KeyAgreement.PublicKey
    public var publicKey: bkey_ios_sdk.K1.KeyAgreement.PrivateKey.PublicKey {
      get
    }
    public init()
    public init(rawRepresentation: some ContiguousBytes) throws
    public init(derRepresentation: some RandomAccessCollection<UInt8>) throws
    public init(pemRepresentation: Swift.String) throws
    public init(x963Representation: some ContiguousBytes) throws
    public var rawRepresentation: Foundation.Data {
      get
    }
    public var derRepresentation: Foundation.Data {
      get
    }
    public var pemRepresentation: Swift.String {
      get
    }
    public var x963Representation: Foundation.Data {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.KeyAgreement.PrivateKey, b: bkey_ios_sdk.K1.KeyAgreement.PrivateKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct PublicKey : Swift.Sendable, Swift.Hashable {
    public init(rawRepresentation: some ContiguousBytes) throws
    public init(derRepresentation: some RandomAccessCollection<UInt8>) throws
    public init(pemRepresentation: Swift.String) throws
    public init(x963Representation: some ContiguousBytes) throws
    public init(compressedRepresentation: some ContiguousBytes) throws
    public var rawRepresentation: Foundation.Data {
      get
    }
    public var derRepresentation: Foundation.Data {
      get
    }
    public var pemRepresentation: Swift.String {
      get
    }
    public var x963Representation: Foundation.Data {
      get
    }
    public var compressedRepresentation: Foundation.Data {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.KeyAgreement.PublicKey, b: bkey_ios_sdk.K1.KeyAgreement.PublicKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.Schnorr {
  public struct PrivateKey : Swift.Sendable, Swift.Hashable {
    public typealias PublicKey = bkey_ios_sdk.K1.Schnorr.PublicKey
    public var publicKey: bkey_ios_sdk.K1.Schnorr.PrivateKey.PublicKey {
      get
    }
    public init()
    public init(rawRepresentation: some ContiguousBytes) throws
    public init(derRepresentation: some RandomAccessCollection<UInt8>) throws
    public init(pemRepresentation: Swift.String) throws
    public init(x963Representation: some ContiguousBytes) throws
    public var rawRepresentation: Foundation.Data {
      get
    }
    public var derRepresentation: Foundation.Data {
      get
    }
    public var pemRepresentation: Swift.String {
      get
    }
    public var x963Representation: Foundation.Data {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Schnorr.PrivateKey, b: bkey_ios_sdk.K1.Schnorr.PrivateKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct PublicKey : Swift.Sendable, Swift.Hashable {
    public init(rawRepresentation: some ContiguousBytes) throws
    public init(derRepresentation: some RandomAccessCollection<UInt8>) throws
    public init(pemRepresentation: Swift.String) throws
    public init(x963Representation: some ContiguousBytes) throws
    public init(compressedRepresentation: some ContiguousBytes) throws
    public var rawRepresentation: Foundation.Data {
      get
    }
    public var derRepresentation: Foundation.Data {
      get
    }
    public var pemRepresentation: Swift.String {
      get
    }
    public var x963Representation: Foundation.Data {
      get
    }
    public var compressedRepresentation: Foundation.Data {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Schnorr.PublicKey, b: bkey_ios_sdk.K1.Schnorr.PublicKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.ECDSA {
  public struct PrivateKey : Swift.Sendable, Swift.Hashable {
    public typealias PublicKey = bkey_ios_sdk.K1.ECDSA.PublicKey
    public var publicKey: bkey_ios_sdk.K1.ECDSA.PrivateKey.PublicKey {
      get
    }
    public init()
    public init(rawRepresentation: some ContiguousBytes) throws
    public init(derRepresentation: some RandomAccessCollection<UInt8>) throws
    public init(pemRepresentation: Swift.String) throws
    public init(x963Representation: some ContiguousBytes) throws
    public var rawRepresentation: Foundation.Data {
      get
    }
    public var derRepresentation: Foundation.Data {
      get
    }
    public var pemRepresentation: Swift.String {
      get
    }
    public var x963Representation: Foundation.Data {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.ECDSA.PrivateKey, b: bkey_ios_sdk.K1.ECDSA.PrivateKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct PublicKey : Swift.Sendable, Swift.Hashable {
    public init(rawRepresentation: some ContiguousBytes) throws
    public init(derRepresentation: some RandomAccessCollection<UInt8>) throws
    public init(pemRepresentation: Swift.String) throws
    public init(x963Representation: some ContiguousBytes) throws
    public init(compressedRepresentation: some ContiguousBytes) throws
    public var rawRepresentation: Foundation.Data {
      get
    }
    public var derRepresentation: Foundation.Data {
      get
    }
    public var pemRepresentation: Swift.String {
      get
    }
    public var x963Representation: Foundation.Data {
      get
    }
    public var compressedRepresentation: Foundation.Data {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.ECDSA.PublicKey, b: bkey_ios_sdk.K1.ECDSA.PublicKey) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.ECDSA {
  public struct Signature : Swift.Sendable, Swift.Hashable, Foundation.ContiguousBytes {
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.ECDSA.Signature {
  public init(derRepresentation: some DataProtocol) throws
  public init(rawRepresentation: some DataProtocol) throws
}
extension bkey_ios_sdk.K1.ECDSA.Signature {
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
}
extension bkey_ios_sdk.K1.ECDSA.Signature {
  public var rawRepresentation: Foundation.Data {
    get
  }
  public var derRepresentation: Foundation.Data {
    get
  }
}
extension bkey_ios_sdk.K1.ECDSA.Signature {
  public static func == (lhs: bkey_ios_sdk.K1.ECDSA.Signature, rhs: bkey_ios_sdk.K1.ECDSA.Signature) -> Swift.Bool
}
extension bkey_ios_sdk.K1.ECDSA.Signature {
  public func hash(into hasher: inout Swift.Hasher)
}
extension bkey_ios_sdk.K1 {
  public enum ASN1Error : Swift.Error {
    case invalidFieldIdentifier
    case unexpectedFieldType
    case invalidObjectIdentifier
    case invalidASN1Object
    case invalidASN1IntegerEncoding
    case truncatedASN1Field
    case unsupportedFieldLength
    case invalidPEMDocument
    public static func == (a: bkey_ios_sdk.K1.ASN1Error, b: bkey_ios_sdk.K1.ASN1Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.Schnorr {
  public struct Signature : Swift.Sendable, Swift.Hashable {
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Schnorr.Signature, b: bkey_ios_sdk.K1.Schnorr.Signature) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.Schnorr.Signature {
  public init(rawRepresentation: some DataProtocol) throws
}
extension bkey_ios_sdk.K1.Schnorr.Signature {
  public var rawRepresentation: Foundation.Data {
    get
  }
}



extension SwiftUI.View {
  public func lazyPop(isEnabled: (SwiftUI.Binding<Swift.Bool>)? = nil) -> some SwiftUI.View
  
}
extension bkey_ios_sdk.K1 {
  public enum Error : Swift.Sendable, Swift.Error, Swift.Hashable {
    case invalidKey
    case incorrectKeySize
    case invalidParameter
    case incorrectParameterSize
    case underlyingLibsecp256k1(error: Swift.Int)
    case internalFailure(error: Swift.UInt)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.Error, b: bkey_ios_sdk.K1.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.Error : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum K1 {
}
extension bkey_ios_sdk.K1.ECDSA.PrivateKey {
  public func signature(for hashed: some DataProtocol, options: bkey_ios_sdk.K1.ECDSA.SigningOptions = .default) throws -> bkey_ios_sdk.K1.ECDSA.Signature
  public func signature(for digest: some Digest, options: bkey_ios_sdk.K1.ECDSA.SigningOptions = .default) throws -> bkey_ios_sdk.K1.ECDSA.Signature
  public func signature(forUnhashed unhashed: some DataProtocol, options: bkey_ios_sdk.K1.ECDSA.SigningOptions = .default) throws -> bkey_ios_sdk.K1.ECDSA.Signature
}
extension bkey_ios_sdk.K1.Schnorr.PrivateKey {
  public func signature(for hashed: some DataProtocol, options: bkey_ios_sdk.K1.Schnorr.SigningOptions = .default) throws -> bkey_ios_sdk.K1.Schnorr.Signature
  public func signature(for digest: some Digest, options: bkey_ios_sdk.K1.Schnorr.SigningOptions = .default) throws -> bkey_ios_sdk.K1.Schnorr.Signature
  public func signature(forUnhashed unhashed: some DataProtocol, options: bkey_ios_sdk.K1.Schnorr.SigningOptions = .default) throws -> bkey_ios_sdk.K1.Schnorr.Signature
}
@inlinable internal func safeCompare<LHS, RHS>(_ lhs: LHS, _ rhs: RHS) -> Swift.Bool where LHS : Foundation.ContiguousBytes, RHS : Foundation.ContiguousBytes {
    lhs.withUnsafeBytes { lhsPtr in
        rhs.withUnsafeBytes { rhsPtr in
            constantTimeCompare(lhsPtr, rhsPtr)
        }
    }
}
@inlinable internal func constantTimeCompare<LHS, RHS>(_ lhs: LHS, _ rhs: RHS) -> Swift.Bool where LHS : Swift.Collection, RHS : Swift.Collection, LHS.Element == Swift.UInt8, RHS.Element == Swift.UInt8 {
    guard lhs.count == rhs.count else {
        return false
    }

    return zip(lhs, rhs).reduce(into: 0) { $0 |= $1.0 ^ $1.1 } == 0
}

extension bkey_ios_sdk.K1 {
  public enum ECDSA {
  }
}
extension bkey_ios_sdk.K1.ECDSA {
  public struct ValidationOptions {
    public let malleabilityStrictness: bkey_ios_sdk.K1.ECDSA.ValidationOptions.MalleabilityStrictness
    public init(malleabilityStrictness: bkey_ios_sdk.K1.ECDSA.ValidationOptions.MalleabilityStrictness)
  }
}
extension bkey_ios_sdk.K1.ECDSA.ValidationOptions {
  public static let `default`: bkey_ios_sdk.K1.ECDSA.ValidationOptions
  public enum MalleabilityStrictness {
    case rejected
    case accepted
    public static func == (a: bkey_ios_sdk.K1.ECDSA.ValidationOptions.MalleabilityStrictness, b: bkey_ios_sdk.K1.ECDSA.ValidationOptions.MalleabilityStrictness) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.ECDSA {
  public struct SigningOptions : Swift.Sendable, Swift.Hashable {
    public let nonceFunction: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction
    public init(nonceFunction: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.ECDSA.SigningOptions, b: bkey_ios_sdk.K1.ECDSA.SigningOptions) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.ECDSA.SigningOptions {
  public static let `default`: bkey_ios_sdk.K1.ECDSA.SigningOptions
  public enum NonceFunction : Swift.Sendable, Swift.Hashable {
    case random
    case deterministic(arbitraryData: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction.RFC6979ArbitraryData? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction, b: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction {
  public struct RFC6979ArbitraryData : Swift.Sendable, Swift.Hashable {
    public let arbitraryData: [Swift.UInt8]
    public static let byteCount: Swift.Int
    public init(arbitraryData: [Swift.UInt8]) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction.RFC6979ArbitraryData, b: bkey_ios_sdk.K1.ECDSA.SigningOptions.NonceFunction.RFC6979ArbitraryData) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@_inheritsConvenienceInitializers @objc(PublicKey) public class PublicKey : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension bkey_ios_sdk.PublicKey {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<bkey_ios_sdk.PublicKey>
  @objc @NSManaged dynamic public var derkey: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var keyId: Swift.Int32 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var name: Swift.String? {
    @objc get
    @objc set
  }
}
extension bkey_ios_sdk.PublicKey : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
extension bkey_ios_sdk.K1.ASN1Error : Swift.Equatable {}
extension bkey_ios_sdk.K1.ASN1Error : Swift.Hashable {}
extension bkey_ios_sdk.K1.ECDSA.ValidationOptions.MalleabilityStrictness : Swift.Equatable {}
extension bkey_ios_sdk.K1.ECDSA.ValidationOptions.MalleabilityStrictness : Swift.Hashable {}
